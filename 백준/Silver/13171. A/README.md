# [Silver III] A - 13171 

[문제 링크](https://www.acmicpc.net/problem/13171) 

### 성능 요약

메모리: 2020 KB, 시간: 0 ms

### 분류

분할 정복을 이용한 거듭제곱, 수학

### 제출 일자

2024년 4월 6일 18:58:16

### 문제 설명

<p>음이 아닌 두 정수 A, X 가 있을 때 A<sup>X</sup>을 구하는 방법을 생각해보자. 물론 이 수는 매우 클 수 있기에, 1,000,000,007 (= 10<sup>9</sup> + 7)로 나눈 나머지를 구할 것이다. a mod x를 a를 x로 나눴을 때의 나머지라고 표현하면,</p>

<p style="text-align:center">(a × b) mod x = {(a mod x) × (b mod x)} mod x</p>

<p>가 성립하기 때문에, 어떤 두 정수를 1,000,000,007로 나눈 나머지만 알고 있어도 그 두 정수의 곱을 1,000,000,007로 나눈 나머지를 쉽게 계산할 수 있다.</p>

<p>본 문제로 돌아가서, 그렇다면 이제 A를 X 번 곱하면 A<sup>X</sup>을 쉽게 구할 수 있을 것 같아 보인다. 그러나 안타깝게도 X가 상당히 커서 64비트 정수의 범위에 있다면 A를 하나하나씩 곱하는 방식으로는 상상할 수 없을 정도로 긴 시간이 흘러야 답을 찾을 수 있을 것이다. 그래서 다음과 같이 곱셈의 횟수를 줄이는 방법을 사용한다.</p>

<ol>
	<li>먼저 A<sup>1</sup>, A<sup>2</sup>, A<sup>4</sup>, A<sup>8</sup>, ...을 순서대로 계산한다. 각 수는 이전에 있는 수를 제곱함으로써 계산할 수 있고, 지수가 X 를 딱 넘지 않을 시점까지만 계산하면 충분할 것이다. X가 64비트 정수의 범위에 있으므로 계산하는 수는 64개보다 작을 것이다.</li>
	<li>이제 X 를 이진수로 나타내 보자. 예를 들어 X를 11로 두면, X = 11 = 1 + 2 + 8이다. 그런데 지수법칙에 의해, A<sup>11</sup> = A<sup>1+2+8</sup> = A<sup>1</sup> × A<sup>2</sup> × A<sup>8</sup>이 성립한다. 이를 통해 1번 단계에서 미리 계산해 놓았던 수 몇 개만 곱해서 A<sup>X</sup> 을 계산할 수 있음을 알 수 있다.</li>
</ol>

<p>즉, 차례로 A를 곱해 나간다면 시간이 X에 비례하게 걸리겠지만, 위의 방법을 이용하면 시간이 log(X)에 비례하게 걸리게 된다. A<sup>X</sup>를 구하는 프로그램을 작성하라.</p>

### 입력 

 <p>첫 번째 줄에는 정수 A(1 ≤ A ≤ 10<sup>18</sup>)이 주어진다.</p>

<p>두 번째 줄에는 정수 X(1 ≤ X ≤ 10<sup>18</sup>)가 주어진다.</p>

### 출력 

 <p>A<sup>X</sup>을 출력한다. 이 수는 매우 커질 수 있으므로 1,000,000,007로 나눈 나머지를 출력해야 한다.</p>

